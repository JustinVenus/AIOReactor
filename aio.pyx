# Copyright (c) 2012 Twisted Matrix Laboratories.
# See LICENSE for details.

"""
Interface to aio I/O event notification facility.
"""

#read setup.py for build details

#TODO document methods and classes
#TODO comment why i did stuff the way i did
#TODO we still aren't actually getting the data out of the objects

#what works:
# basic infrastructure is put together, it compiles and loads in python

#what doesn't work:
# not functional for any real work at this point

from libc.stdio cimport const_char
from libc.stdint cimport intptr_t
from posix.unistd cimport off_t
from cpython cimport mem
import time #FIXME use native time calls in the future


cdef extern from "errno.h":
    cdef extern int errno
    cdef extern char *strerror(int)

cdef extern from "Python.h":
    ctypedef struct PyObject
    ctypedef struct PyThreadState
    cdef extern PyThreadState *PyEval_SaveThread()
    cdef extern void PyEval_RestoreThread(PyThreadState*)

cdef extern from "sys/time.h" nogil:
    cdef struct timeval:
        long tv_sec
        long tv_usec

cdef extern from "sys/aio.h" nogil:
    cdef struct aio_result_t:
        ssize_t aio_return     # return value of read or write
        int aio_errno          # errno generated by the IO
    ctypedef aio_result_t aio_result_t

    enum: AIOREAD
    enum: AIOWRITE
    enum: AIOWAIT
    enum: AIOCANCEL
    enum: AIONOTIFY
    enum: AIOINIT
    enum: AIOSTART
    enum: AIOLIO
    enum: AIOSUSPEND
    enum: AIOERROR
    enum: AIOLIOWAIT
    enum: AIOAREAD
    enum: AIOAWRITE
    enum: AIOFSYNC
    enum: AIOWAITN
    enum: AIORESERVED1
    enum: AIORESERVED2
    enum: AIORESERVED3

cdef extern from "sys/asynch.h" nogil:
    enum: AIO_INPROGRESS #we can use this as a marker

#TODO throw exception
    cdef int aioread(
        int fildes,
        char *bufp,
        int bufs,
        off_t offset,
        int whence,
        aio_result_t *resultp
    )

#TODO throw exception
    cdef int aiowrite(
        int fildes,
        const_char *bufp,
        int bufs,
        off_t offset,
        int whence,
        aio_result_t *resultp
    )

#TODO throw exception
    cdef aio_result_t *aiowait(timeval *)


#user defined structure
cdef extern struct _state_t:
    aio_result_t *aiores #leave this here so we can cast!!!
    PyObject *this #convience so we can get to the reader or writer
    int fd
ctypedef _state_t reactor_state_t


cdef class _baseio(object):
    """handles the low level memory management"""
    cdef reactor_state_t *fdio 
    def __cinit__(self):
        *self.fdio = <reactor_state_t*>mem.PyMem_Malloc(
            sizeof(reactor_state_t)
        )
        #this is so we can look up self in aio.wait
        self.fdio.this = <PyObject *>self
        #TODO ^figure out if we need to reference count that
        if self.fdio is NULL:
            raise MemoryError()

    def __dealloc__(self):
        if self.fdio is not NULL:
            if self.fdio.aiores is not NULL:
                mem.PyMem_Free(self.fdio.aiores)
            mem.PyMem_Free(self.fdio)

    property fd:
        def __get__(self):
            return self.fdio.fd
        def __set__(self, value):
            raise AttributeError('This property is not setable')
        def __del__(self): pass

    property code:
        def __get__(self):
            return self.fdio.aiores.aio_return
        def __set__(self, value):
            raise AttributeError('This property is not setable')
        def __del__(self): pass

    property errno:
        def __get__(self):
            return self.fdio.aiores.aio_errno
        def __set__(self, value):
            raise AttributeError('This property is not setable')
        def __del__(self): pass

    property ready:
        def __get__(self):
            if self._ready: #first pass nothing has been initiallized
                self._ready = False #don't forget to block this
                return True #allows this to pass once
            return bool(self.fdio.aiores.aio_return != AIO_INPROGRESS)
        def __set__(self, value):
            raise AttributeError('This property is not setable')
        def __del__(self): pass

    def __init__(self, int fd):
        self.data = '' #this is your data
        self.fdio.fd = fd
        *self.fdio.aiores = <aio_result_t*>mem.PyMem_Malloc(
            sizeof(aio_result_t)
        )
        if self.fdio.aiores is NULL:
            raise MemoryError()
        self._ready = True

    cdef int dispatch(self) with gil:
        """gets called when we are ready to dispatch"""
        raise NotImplemented()


cdef class reader(_baseio):
    """
    Represent a file descriptor being monitored for reading.
    """
    cdef char *_buffer
    cdef int len_buffer

    def __cinit__(self):
        self.len_buffer = 0
        self._buffer = NULL
        _baseio.__cinit__(self)

    def __dealloc__(self):
        if self._buffer is not NULL:
            mem.PyMem_Free(self._buffer)
        _baseio.__dealloc__(self)

    cdef int dispatch(self) with gil:
        if not self.ready: return AIO_INPROGRESS
        #set a marker so we can check it later
        self.fdio.aiores.aio_return = AIO_INPROGRESS 
        if self._buffer is NULL:
            *self._buffer = <char *>mem.PyMem_Malloc(
                self.len_buffer
            )
        else:
            *self._buffer = <char *>mem.PyMem_Realloc(
                self._buffer, self.len_buffer
            )
        if self._buffer is NULL:
            raise MemoryError()
        return aioread(
            self.fdio.fd,
            self._buffer,
            self.len_buffer,
            0, #TODO we may need to set this later
            0, #TODO we may need to set this later
            self.fdio.aiores
        )

    def read(self, int size):
        if self.ready:
            self.len_buffer = size
            return self.dispatch()


cdef class writer(_baseio):
    """
    Represent a file descriptor being monitored for writing.
    """
    cdef int dispatch(self) with gil:
        if not self.ready: return AIO_INPROGRESS
        #set a marker so we can check it later
        self.fdio.aiores.aio_return = AIO_INPROGRESS 
        cdef char *data
        data = self.data
        self.data = '' #reset data buffer
        return aiowrite(
            self.fdio.fd,
            data,
            len(data),
            0, #TODO we may need to set this later
            0, #TODO we may need to set this later
            self.fdio.aiores
        )

    def write(self, char *data):
        self.data += data
        if self.ready:
            return self.dispatch()


cdef class aio(object):
    """
    Represent a set of file descriptors being monitored for events.
    """

    def __init__(self):
        self._readers = {}
        self._writers = {}
        self._pending = []

    def addReader(self, int fd):
        if fd in self._readers: return
        self._readers.update({fd: reader(fd)})

    def addWriter(self, int fd):
        if fd in self._readers: return
        self._writers.update({fd: writer(fd)})

    def removeReader(self, int fd):
        if fd not in self._readers: return
        del self._readers[fd]

    def removeWriter(self, int fd):
        if fd not in self._writers: return
        del self._writers[fd]

    def wait(self, timeout):
        """
        Wait for an I/O event, wrap aiowait(3C).

        @type timeout: C{int} or C{float}
        @param timeout: Maximum time waiting for events. 0 makes it wait
            indefinitely.  Don't use 0 for your timeout!!!
        
        @raise IOError: Raised if the underlying aiowait() call fails.
        """
        self.running = 1
        cdef PyThreadState *_save
        cdef reactor_state_t *result
        cdef aio_result_t *aioptr
        cdef timeval val
        timeout = float(timeout)
        #FIXME this next line makes me feel dirty
        sec, usec = str(timeout).split('.')
        val.tv_sec = int(sec)
        val.tv_usec = int(usec)
        #collect results
        results = []
        future = time.time() + timeout
        #we can only dequeue one item at a time
        while future > time.time():
             _save = PyEval_SaveThread()
             #de-queue one item
             aioptr = aiowait(&val)
             PyEval_RestoreThread(_save)
             #see man page for cast strategy
             if 0 == <long>aioptr:
                 break #timed out no events captured
             if -1 == <long>aioptr:
                 raise IOError(errno, strerror(errno))
             #cast the aio_result_t to reactor_state_t
             result = <reactor_state_t*>aioptr
             if result is NULL: continue
             #push/pull data from the original reader/writer object
             x = <object>result.this
             if x: results.append(x)
        return results


#enumerated values mapped to python values
AIO_READ = AIOREAD
AIO_WRITE = AIOWRITE
AIO_WAIT = AIOWAIT
AIO_CANCEL = AIOCANCEL
AIO_NOTIFY = AIONOTIFY
AIO_INIT = AIOINIT
AIO_START = AIOSTART
AIO_LIO = AIOLIO
AIO_SUSPEND = AIOSUSPEND
AIO_ERROR = AIOERROR
AIO_LIOWAIT = AIOLIOWAIT
AIO_AREAD = AIOAREAD
AIO_AWRITE = AIOAWRITE
AIO_FSYNC = AIOFSYNC
AIO_WAITN = AIOWAITN
AIO_RESERVED1 = AIORESERVED1
AIO_RESERVED2 = AIORESERVED2
AIO_RESERVED3 = AIORESERVED3

__all__ = ['reader', 'writer', 'aio', 'AIO_READ', 'AIO_WRITE', 'AIO_WAIT', 
    'AIO_CANCEL', 'AIO_NOTIFY', 'AIO_INIT', 'AIO_START', 'AIO_LIO', 'AIO_SUSPEND',
    'AIO_ERROR', 'AIO_LIOWAIT', 'AIO_AREAD', 'AIO_AWRITE', 'AIO_FSYNC', 'AIO_WAITN',
    'AIO_RESERVED1', 'AIO_RESERVED2', 'AIO_RESERVED3'
]
